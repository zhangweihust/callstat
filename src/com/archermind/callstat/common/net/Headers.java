package com.archermind.callstat.common.net;

import java.util.ArrayList;

import org.apache.http.Header;
import org.apache.http.protocol.HTTP;
import org.apache.http.util.CharArrayBuffer;

import com.archermind.callstat.DebugFlags;

public final class Headers {
	private static final String LOGTAG = "Net_Headers";
	/**
	 * indicate HTTP 1.0 connection close after the response
	 */
	public final static int CONN_CLOSE = 1;
	/**
	 * indicate HTTP 1.1 connection keep alive
	 */
	public final static int CONN_KEEP_ALIVE = 2;

	// initial values.
	public final static int NO_CONN_TYPE = 0;
	public final static long NO_TRANSFER_ENCODING = 0;
	public final static long NO_CONTENT_LENGTH = -1;

	// header strings
	public final static String TRANSFER_ENCODING = "transfer-encoding";
	public final static String CONTENT_LEN = "content-length";
	public final static String CONTENT_TYPE = "content-type";
	public final static String CONTENT_ENCODING = "content-encoding";
	public final static String CONN_DIRECTIVE = "connection";

	public final static String LOCATION = "location";
	public final static String PROXY_CONNECTION = "proxy-connection";

	public final static String WWW_AUTHENTICATE = "www-authenticate";
	public final static String PROXY_AUTHENTICATE = "proxy-authenticate";
	public final static String CONTENT_DISPOSITION = "content-disposition";
	public final static String ACCEPT_RANGES = "accept-ranges";
	public final static String EXPIRES = "expires";
	public final static String CACHE_CONTROL = "cache-control";
	public final static String LAST_MODIFIED = "last-modified";
	public final static String ETAG = "etag";
	public final static String SET_COOKIE = "set-cookie";
	public final static String PRAGMA = "pragma";
	public final static String REFRESH = "refresh";
	public final static String X_PERMITTED_CROSS_DOMAIN_POLICIES = "x-permitted-cross-domain-policies";

	// following hash are generated by String.hashCode()
	private final static int HASH_TRANSFER_ENCODING = 1274458357;
	private final static int HASH_CONTENT_LEN = -1132779846;
	private final static int HASH_CONTENT_TYPE = 785670158;
	private final static int HASH_CONTENT_ENCODING = 2095084583;
	private final static int HASH_CONN_DIRECTIVE = -775651618;
	private final static int HASH_LOCATION = 1901043637;
	private final static int HASH_PROXY_CONNECTION = 285929373;
	private final static int HASH_WWW_AUTHENTICATE = -243037365;
	private final static int HASH_PROXY_AUTHENTICATE = -301767724;
	private final static int HASH_CONTENT_DISPOSITION = -1267267485;
	private final static int HASH_ACCEPT_RANGES = 1397189435;
	private final static int HASH_EXPIRES = -1309235404;
	private final static int HASH_CACHE_CONTROL = -208775662;
	private final static int HASH_LAST_MODIFIED = 150043680;
	private final static int HASH_ETAG = 3123477;
	private final static int HASH_SET_COOKIE = 1237214767;
	private final static int HASH_PRAGMA = -980228804;
	private final static int HASH_REFRESH = 1085444827;
	private final static int HASH_X_PERMITTED_CROSS_DOMAIN_POLICIES = -1345594014;

	// keep any headers that require direct access in a presized
	// string array

	private final static int IDX_CONTENT_LEN = 1;
	private final static int IDX_CONTENT_TYPE = 2;
	private final static int IDX_EXPIRES = 11;
	private final static int IDX_CACHE_CONTROL = 12;
	private final static int IDX_LAST_MODIFIED = 13;
	private final static int IDX_ETAG = 14;
	private final static int IDX_REFRESH = 17;

	private final static int HEADER_COUNT = 19;

	/* parsed values */
	private long transferEncoding;
	private long contentLength; // WContent length of the incoming data
	private int connectionType;
	private ArrayList<String> cookies = new ArrayList<String>(2);

	private String[] mHeaders = new String[HEADER_COUNT];

	// Catch-all for headers not explicitly handled
	private ArrayList<String> mExtraHeaderNames = new ArrayList<String>(4);
	private ArrayList<String> mExtraHeaderValues = new ArrayList<String>(4);

	public Headers() {
		transferEncoding = NO_TRANSFER_ENCODING;
		contentLength = NO_CONTENT_LENGTH;
		connectionType = NO_CONN_TYPE;
	}

	public void setHeader(Header header) {
		if (header == null) {
			return;
		}
		String name = header.getName().toLowerCase();
		String val = header.getValue();

		if (DebugFlags.HEADS) {
			HttpLog.v("setHeader-name:" + name + " value:" + val);
		}

		switch (name.hashCode()) {
		case HASH_CONTENT_LEN:
			if (name.equals(CONTENT_LEN)) {
				mHeaders[IDX_CONTENT_LEN] = val;
				try {
					contentLength = Long.parseLong(val);
				} catch (NumberFormatException e) {
					if (DebugFlags.HEADS) {
						HttpLog.v("Headers.headers(): error parsing"
								+ " content length: " + val);
					}
				}
			}
			break;
		case HASH_CONTENT_TYPE:
			if (name.equals(CONTENT_TYPE)) {
				mHeaders[IDX_CONTENT_TYPE] = val;
			}
			break;
		case HASH_EXPIRES:
			if (name.equals(EXPIRES)) {
				mHeaders[IDX_EXPIRES] = val;
			}
			break;
		case HASH_CACHE_CONTROL:
			if (name.equals(CACHE_CONTROL)) {
				mHeaders[IDX_CACHE_CONTROL] = val;
			}
			break;
		case HASH_LAST_MODIFIED:
			if (name.equals(LAST_MODIFIED)) {
				mHeaders[IDX_LAST_MODIFIED] = val;
			}
			break;
		case HASH_ETAG:
			if (name.equals(ETAG)) {
				mHeaders[IDX_ETAG] = val;
			}
			break;
		case HASH_REFRESH:
			if (name.equals(REFRESH)) {
				mHeaders[IDX_REFRESH] = val;
			}
			break;
		default:
			mExtraHeaderNames.add(name);
			mExtraHeaderValues.add(val);
			if (DebugFlags.HEADS) {
				HttpLog.v("mExtraHeaderNames:" + name + " value:" + val);
			}
		}
	}

	public long getTransferEncoding() {
		return transferEncoding;
	}

	public long getContentLength() {
		return contentLength;
	}

	public int getConnectionType() {
		return connectionType;
	}

	public String getContentType() {
		return mHeaders[IDX_CONTENT_TYPE];
	}

	public String getExpires() {
		return mHeaders[IDX_EXPIRES];
	}

	public String getCacheControl() {
		return mHeaders[IDX_CACHE_CONTROL];
	}

	public String getLastModified() {
		return mHeaders[IDX_LAST_MODIFIED];
	}

	public String getEtag() {
		return mHeaders[IDX_ETAG];
	}

	public ArrayList<String> getSetCookie() {
		return this.cookies;
	}

	public String getRefresh() {
		return mHeaders[IDX_REFRESH];
	}

	public void setContentLength(long value) {
		this.contentLength = value;
	}

	public void setContentType(String value) {
		mHeaders[IDX_CONTENT_TYPE] = value;
	}

	public void setExpires(String value) {
		mHeaders[IDX_EXPIRES] = value;
	}

	public void setCacheControl(String value) {
		mHeaders[IDX_CACHE_CONTROL] = value;
	}

	public void setLastModified(String value) {
		mHeaders[IDX_LAST_MODIFIED] = value;
	}

	public void setEtag(String value) {
		mHeaders[IDX_ETAG] = value;
	}

	public interface HeaderCallback {
		public void header(String name, String value);
	}

	private void setConnectionType(CharArrayBuffer buffer, int pos) {
		if (CharArrayBuffers.containsIgnoreCaseTrimmed(buffer, pos,
				HTTP.CONN_CLOSE)) {
			connectionType = CONN_CLOSE;
		} else if (CharArrayBuffers.containsIgnoreCaseTrimmed(buffer, pos,
				HTTP.CONN_KEEP_ALIVE)) {
			connectionType = CONN_KEEP_ALIVE;
		}
	}
}